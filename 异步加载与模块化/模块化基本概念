模块化基本概念

1.为何需要模块化
	代码组织

2.模块化解决了什么问题？

	A：将一段代码组织为一个单元，并注册

	B：单元之间的依赖引用
		这块其实包含很多问题：
			单元模块的加载：有异步加载 有同步加载， 也有初始化的时候就全部加载
			单元模块的执行时间： 
				在真正requrie的时候需要使用依赖模块的时候就执行（seajs，）
				在被依赖的模块执行前 就执行（require,angularjs）

	C：浏览器端的一个问题：异步单元依赖


3.CommonJs
	服务器端模块规范，解决上诉两个问题，文件都是同步加载


4.AMD（Asynchronous Module Definition）
	浏览器下，文件只能是异步加载，所以必须等依赖文件加载完毕后执行，

5.Commonjs与AMD主要设计思想不同

	CommonJs与AMD都存在文件依赖 以及加载顺序的问题，只不过一个是同步加载，一个是异步加载


6.Angularjs模块方案
	
	Angularjs也解决了两个问题：
		A：代码组织与注册
		B：单元的依赖
			这里依赖这块，angularjs解决的方案更好，
			因为模块内部的方法都是延迟执行，所以对模块文件的加载顺序没有要求，
			而不论是cmmonjs还是AMD对模块文件的加载顺序都有要求

			模块之间的依赖对加载顺序没有影响（require指定哪个模块先加载）
			但是模块内部 的 provider 如果互相之间的provider有依赖，则必须保证顺序

	存在的问题：

		1.运行期无法再加载模块等

		2.无异步加载文件的功能

	解决办法：

		1.如果运行期需要加载指令模块等，就必须改变模块的加载方式
			模块可以还是延长将指令加到模块的cache queue中，但是必须有一点去统一执行queue将，指令等加到注射容器中
			这个执行点 就是依赖的文件加载完毕，why，因为这里可能包含子指令，或者依赖的模块的服务

		2.引进seajs，但是我们不使用他的模块方案，
			seajs主要处理两个方面的问题，
				负责依赖js文件的加载，以及加载完毕后的回掉。
				但是seajs的回掉是使用use的回掉，所以需要改下源码，加入invokback，也就是依赖文件全部加载完成后执行的函数，在这里函数里面
				将当前模块的所以cache queue执行。
7. ADM（requiresjs） ， CMD（seajs） 以及 angularjs


	1.amd
		require，没看过源码不太了解
		提前执行，
		因为要提前执行，所以amd格式打包的时候，需要依赖顺序

	2.cmd：
		就近原则，延迟执行
		define(id,requrie,functon(){

		})

		这里的define执行的时候，并没有执行factory代码，只是新建一个module，并且从factory中分析出依赖，将依赖关系写入module中，

		而真正执行是use的时候。use的时候会将模块的依赖模块全部执行，然后再执行本模块。

		那么其实，这种机制下，只要包装use的时候，模块注册了就可以了，
		so，合并或者文件全部通过script引用的话，也是不需要处理加载顺序的。




	3.angularjs
		模块定义:angular.module('test',['','',''])

		这个module也没有执行什么代码，只是新建了一个module，将依赖存入module中，

		而loadmodule的时候，也是先将子模块先执行完（这个执行比较复杂不是简单的执行函数），然后再执行本模块。
		so,这里的模块是不需要处理加载顺序的，主要引入的时候注册好了就OK了··

	总结：

		对比ｓｅａ　与ａｎｇｕｌａｒ

		1.如果不考虑异步加载，在js文件都引入的情况下，那么sea与angular的模块本质是一样的，都是定义模块的时候保存依赖关系，真正加载的时候再执行模块，这样的话，模块的引入完全不需要顺序。

		2.异步：
			sea:由于执行异步加载，所以sea的模块名与url路径有一种转换关系。
				再查找模块时候，如果模块cache对应的模块名不存在，那么则会将模块名对应成url，然后加载这个url文件，
				如果这个文件名不存在，那么则代表这个模块加载失败

				sea的模块，是通过一个factory函数生成的，

			angular：不存在异步加载机制，所以模块都是简单string，与url无关
					so,到，这一步，可以想到，如果要angular完美支持异步加载，则在loadmodule这块，如果模块找不到，则将模块名转换为对应的url加载这个文件的模块。就OK了，当然这样做是有很多代价的，但是这样貌似也有很多问题：1.css文件的加载，2.angular的模块通常会有多个文件。

					angularjs的模块拥有相对复杂的结构，而模块的扩展（指令，provide，service），也是延长加载的，可以说是类似模块的概念，先存好，等真正加载的时候再加载

					所以模块的文件之间加载顺序没有影响，不同模块的子文件加载顺序依赖是没有影响。
					但是有一点，一个模块之间，的provider有依赖的化 加载顺序就有影响（仅provider，而不是实例 ）
		3.模块执行时间。
			sea，的模块依赖，只是负责把模块加载进来，但是并没有真正的执行
			angular的模块依赖，由于没有异步加载，所以是之间执行模块。


关于JS模块化
https://github.com/seajs/seajs/issues/588
1.Modules/1.x 流派
	也就是跟服务器端的规范差不多··，用在浏览器端的化，再用Modules/Transport 规范进行一次转换
2.Modules/Async  AMD/requireJs

3.Modules2.0
	标准的2.0，项目 大部分都end了。
	CMD（seajs）来源与此



