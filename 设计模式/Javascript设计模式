Javascript设计模式


##设计模式的种类

1.创建型设计模式
关注对象创建的机制方法，由于基本的对象创建或者说分散随意的对象创建可能会导致项目比较混乱，所以这个模式就是 通过控制创建过程来解决这个问题

主要设计模式如下:
	构造器模式(constructor)，工厂模式(factory)，抽象工厂(abstract)，原型模式(prototype)，单例模式(singleton)，构建者模式(builder)

2.结构设计模式
关注于对象组合以及对象之间关系，主要适用情况是：系统部分发送改变时，系统结构不需要改变，个人理解，就是对象与对象之间的接口吧··

	装饰模式，外观模式，享元模式，适配器模式，代理模式

3.行为设计模式
关注于改善或精简系统中对象之间的通信

	迭代模式，中介者模式，观察者模式，访问者模式

##设计模式详解

===== 下面是创建型模式 =====

###构造器模式

1.基础构造器
无法继承，无法共享方法

	function Car(type){
		this.name='fute';
		this.type = type;
	}

	var fute = new Car()

2.原型构造器

	function Car(){
		this.name='fute';
	}

	Car.prototype ={
		...
	}
	var fute = new Car()

###模块模式

1.对象字面量
	var module = {
		name:'test',
		doRun:function(){
			...
		}
	}

2.模块化形式
核心问题就是：暴露公有方法或变量，屏蔽私有方法或变量，由于js没有访问修饰符，只有通过函数域来实现私有化信息。

优势：
	可以创建仅模块内部可访问的私有函数、变量。
	调试方便，可看到调用栈，因为函数都是正常声明（有空了解下，匿名函数或者说没有函数名的函数，调试的栈的问题）

这个例子通过自包含的形式，以闭包来私有化，很常见的模式，在很多框架中都有，
这里使用立即执行，那么整个系统只能返回一个这个模块。

	var myNamespace = (function () {

	  var myPrivateVar, myPrivateMethod;

	  // A private counter variable
	  myPrivateVar = 0;

	  // A private function which logs any arguments
	  myPrivateMethod = function( foo ) {
	      console.log( foo );
	  };

	  return {

	    // A public variable
	    myPublicVar: "foo",

	    // A public function utilizing privates
	    myPublicFunction: function( bar ) {

	      // Increment our private counter
	      myPrivateVar++;

	      // Call our private method using bar
	      myPrivateMethod( bar );

	    }
	  };

	})();

dojo、YUI、EXTJS、JQUERY 都有类似的应用

### 建造模式
将复杂的对象创建封装在对象内部


===== 下面是结构模式 =====


### 适配器模式
基于客户提供的接口和功能，在此基础上实现具体的业务功能。

通过已提供的业务对象类，来实现特定的业务功能，两种方式，通过实现接口，或者继承抽象类

1.类适配器

继承业务BO，然后在实现业务功能接口

2.对象适配器
提供的是抽象类而不是接口，
那么新的类只能继承抽象类，而业务对象通过参数传入

区别:类适配器 可以重载父类的方法，对象适配器通过提供包装方法来改变
这两个命名：一个是通过类的继承，一个是通过对象传入，所以这样叫把


### 桥接模式


### 外观模式/门面模式
给子系统定义一个高层的接口吧，外包系统访问这个系统都通过接口的方法来调用

主要是解决子系统跟外部系统的耦合关系吧

### 组合模式
主要是将对象组合起来吧（树形结构），并且对外提供一致的接口，
这样客户就不需要关系具体是单个对象还是组合的对象，或者说有多少个对象
另外就是组合体内部如果加入了对象，外部是不需要改变的

### 装饰器模式
应用场景：某个类需要新的行为，但是这个行为变化是比较少，而且比较灵活

对于某些小的功能使用单独的类似来实现，而且这个实现是通过传入以前的类，
这样就可以复用，而且方便灵活的组合

最典型的应用就是 java io流操作类


### 代理模式
代理模式通过建立一个占位对象，来控制对目标对象的访问，
为什么需要呢，因为目标对象可能会因为各种原因失败等，这个时候代理对象可能就需要做些额外的处理

### 享元模式
将程序中重复使用的元素集中起来，达到节省资源开销的目的吧
cache



===== 下面是行为模式 =====

###命令模式

提供一个命令接口，具体实现方法写在命令接口的执行方法内部

 
### 解释器模式
不甚理解，大概类似commond，但是又不同于comnond，因为不是单个对象调用

### 状态模式
就是将一个对象的状态 封装到一个单独的对象中，这个对象负责所以状态变化相关的代码，

### 策略模式
策略来定义策略的输入输出，而策略的实现交给具体的类

将策略的选择逻辑与策略的本身分离。

核心思想：将一个可能根据情况来处理的逻辑（switch） 根据策略的不同分别放在不同的类中，这些类共用一个接口

### 模板方法
根据模板添加相应的业务实现、

一般模板都是抽象类，里面实现了一些公共方法，也会定义一些方法由子类来实现

### 备忘录模式
提供状态的存储与恢复功能

### 观察者模式
定义多个对象之间的一对多关系，当被观察者状态改变时，观察者可以得到通知

### 责任链模式

主要是避免请求者跟接受者之间的耦合吧···当有请求来的时候，遍历接受者，对于每一个请求，接受者都可以解决自己是否处理

### 中介者模式
对象群组关系比较复杂的时候，可以建立一个中间的机构来负责控制他们的交互，这样降低对象群组之间的耦合

### 访问者模式
在不修改现有类层次结构的情况下，为该类层级结构定义新的操作

类的层级结构每一次 要提供accept方法，这个方法传入visite对象，然后执行，感觉有点控制翻转的意思··

