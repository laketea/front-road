Javascript设计模式


##设计模式的种类

1.创建型设计模式
关注对象创建的机制方法，由于基本的对象创建或者说分散随意的对象创建可能会导致项目比较混乱，所以这个模式就是 通过控制创建过程来解决这个问题

主要设计模式如下:
	构造器模式(constructor)，工厂模式(factory)，抽象工厂(abstract)，原型模式(prototype)，单例模式(singleton)，构建者模式(builder)

2.结构设计模式
结构型模式涉及到如何组合类和对象以获得更大的结构。
这里有两种类型：
	结构型类模式：采用继承机制来组合接口与实现（类适配器）
	接口型对象模式：对对象进行组合
主要适用情况是：系统部分发送改变时，系统结构不需要改变，个人理解，就是对象与对象之间的接口吧··

	装饰模式，外观模式，享元模式，适配器模式，代理模式

3.行为设计模式
行为模式涉及到算法和对象间职责的分配，还有描述对象间的通信，
将复杂的控制流，转移到对象间的联系方式上

	迭代模式，中介者模式，观察者模式，访问者模式

##设计模式详解

===== 下面是创建型模式 =====

### 工厂模式
1.简单工厂模式
	静态工厂方法模式，定义一个用于创建对象的接口。
	通俗点说，就是一个方法，负责创建所有对象，根据传入的参数，来决定创建什么类型的对象。

2.工厂方法
	定义一个用于创建对象的接口，让子类决定实例化哪一个类，
	具体做法就是，将工厂接口继承为多个子类，不同的子类创建不同的对象，通俗点将就是不在是一个大工厂负责建造所以的对象，而且拆分成不同的小工厂，
	小工厂负责建造具体的对象

3.抽象工厂
	为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。

	产品族：可以理解为产品的品牌类似的概念，比如AMD 的主板，cpu等是一个家族
	产品等级： 可以理解为产品的本质类型，比如说主板是一种类型，而cpu又是一个类型

	抽象工厂以产品族为一个子工厂，该工厂实现生产所以等级的产品的方法，这样的话，整个结构很清晰

	public class AMDFactor implement factory{
		private createCpu(){..},

		private createGPu{..},

		private ctreateNC{..},
	}

	这样的好处就是面对接口编程，因为无论是子工厂都是实现了固定的接口，客户只需要使用接口定义的方法就可以，不需要关心怎么创建的

	扩展产品族方便，但是扩展产品等级不方便。

工厂方法模式针对的是一个产品等级结构；
而抽象工厂模式则需要面对多个产品等级结构


### Builder模式
	将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
	这个模式的祝重点是一步一步构造一个复杂对象。
	而工厂模式是一下就把对象构造出来

	这里有两个角色，builder以及director

	builder负责产品制作的各个部分例如：
		builder{
			builderCpu()

			bulderMemory;

			builderGPU:

			getComputer:
		}

	director:
		负责选择合适的builder，例如可能有不同品牌的builder，
		而且director可以指导构架过程,可以选择具体要构造哪些部分，哪些部分不构造

		director:

			builder.bulderCpu,
			builder.builderGpu,




###构造器模式

1.基础构造器
无法继承，无法共享方法

	function Car(type){
		this.name='fute';
		this.type = type;
	}

	var fute = new Car()

2.原型构造器

	function Car(){
		this.name='fute';
	}

	Car.prototype ={
		...
	}
	var fute = new Car()

###模块模式

1.对象字面量
	var module = {
		name:'test',
		doRun:function(){
			...
		}
	}

2.模块化形式
核心问题就是：暴露公有方法或变量，屏蔽私有方法或变量，由于js没有访问修饰符，只有通过函数域来实现私有化信息。

优势：
	可以创建仅模块内部可访问的私有函数、变量。
	调试方便，可看到调用栈，因为函数都是正常声明（有空了解下，匿名函数或者说没有函数名的函数，调试的栈的问题）

这个例子通过自包含的形式，以闭包来私有化，很常见的模式，在很多框架中都有，
这里使用立即执行，那么整个系统只能返回一个这个模块。

	var myNamespace = (function () {

	  var myPrivateVar, myPrivateMethod;

	  // A private counter variable
	  myPrivateVar = 0;

	  // A private function which logs any arguments
	  myPrivateMethod = function( foo ) {
	      console.log( foo );
	  };

	  return {

	    // A public variable
	    myPublicVar: "foo",

	    // A public function utilizing privates
	    myPublicFunction: function( bar ) {

	      // Increment our private counter
	      myPrivateVar++;

	      // Call our private method using bar
	      myPrivateMethod( bar );

	    }
	  };

	})();

dojo、YUI、EXTJS、JQUERY 都有类似的应用

### 建造模式
将复杂的对象创建封装在对象内部


===== 下面是结构模式 =====


### 适配器模式
基于客户提供的接口和功能，在此基础上实现具体的业务功能。

通过已提供的业务对象类，来实现特定的业务功能，两种方式，通过实现接口，或者继承抽象类

1.类适配器

继承业务BO，然后在实现业务功能接口

2.对象适配器
提供的是抽象类而不是接口，
那么新的类只能继承抽象类，而业务对象通过参数传入

区别:类适配器 可以重载父类的方法，对象适配器通过提供包装方法来改变
这两个命名：一个是通过类的继承，一个是通过对象传入，所以这样叫把


### 桥接模式
将抽象部分与它的实现部分分离，使它们都可以独立地变化
或者说 对象与其行为解耦，分离出来。

### 外观模式/门面模式
给子系统定义一个高层的接口吧，外包系统访问这个系统都通过接口的方法来调用

主要是解决子系统跟外部系统的耦合关系吧

### 组合模式
主要是将对象组合起来吧（树形结构），并且对外提供一致的接口，
这样客户就不需要关系具体是单个对象还是组合的对象，或者说有多少个对象
另外就是组合体内部如果加入了对象，外部是不需要改变的

### 装饰器模式
动态的给一个对象添加额外的职责

避免了静态实现所以组合功能子类，导致的子类急剧增多

这里的一个最大的特点就是动态，以及对象，是给对象添加额外的职责，而不是给类添加

由于包装类也使用相同的接口，所以可以自由组合，更灵活

这里跟对象适配器有点类似，但是区别是对象适配器跟组合的对象是不同的接口，所以无法组合，而这里装饰器类与业务对象
保持一样的接口，所以可以动态组合

装饰模式是改变对象的外表，而策略模式是改变对象的内核

最典型的应用就是 java io流操作类


### 代理模式
代理模式通过建立一个占位对象，来控制对目标对象的访问，
为什么需要呢，因为目标对象可能会因为各种原因失败等，这个时候代理对象可能就需要做些额外的处理

### 享元模式
将程序中重复使用的元素集中起来，达到节省资源开销的目的吧
cache



===== 下面是行为模式 =====

###命令模式

提供一个命令接口，具体实现方法写在命令接口的执行方法内部

 
### 解释器模式
定义语言的文法，并且简历一个解释其来解释该语言中的句子

	a+b+2
	抽象表达式角色：所以表达式的接口
	终结符表达式角色：就是这里的，a，b，2，终结表达式一般只有一个，但是有多个实例
	非终结符表达式角色：每个文法规则对应一个非终结符表达式角色，再这里+号就是。
	环境角色：全局参数吧

### 状态模式
就是将一个对象的状态 封装到一个单独的对象中，这个对象负责所以状态变化相关的代码，

### 策略模式
策略来定义策略的输入输出，而策略的实现交给具体的类

将策略的选择逻辑与策略的本身分离。

核心思想：将一个可能根据情况来处理的逻辑（switch） 根据策略的不同分别放在不同的类中，这些类共用一个接口

### 模板方法
根据模板添加相应的业务实现、

一般模板都是抽象类，里面实现了一些公共方法，也会定义一些方法由子类来实现

### 备忘录模式
提供状态的存储与恢复功能

### 观察者模式
定义多个对象之间的一对多关系，当被观察者状态改变时，观察者可以得到通知

### 责任链模式

主要是避免请求者跟接受者之间的耦合吧···当有请求来的时候，遍历接受者，对于每一个请求，接受者都可以解决自己是否处理

### 中介者模式
对象群组关系比较复杂的时候，可以建立一个中间的机构来负责控制他们的交互，这样降低对象群组之间的耦合

### 访问者模式
在不修改现有类层次结构的情况下，为该类层级结构定义新的操作

类的层级结构每一次 要提供accept方法，这个方法传入visite对象，然后执行，感觉有点控制翻转的意思··

